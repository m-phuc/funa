interface FnExpr {
	name: string;
	args?: (string | number)[];
}

interface SrcExpr {
	bind: boolean;
	prop: string;
	path: string[];
}

interface TplExpr {
	name: string;
}

interface IfExpr {
	not: boolean;
	hnd: FnExpr;
}

interface IsExpr {
	name: string;
}

interface OnExpr {
	evt: string;
	hnd: FnExpr;
}

interface BindExpr {
	src?: SrcExpr;
	tpl?: TplExpr;
	if?: IfExpr;
	is?: IsExpr;
	on?: OnExpr[];
}

interface TextExpr {
	run?: string;
	src?: SrcExpr;
	fmt?: FnExpr;
}

interface AtExpr {
	evt: string;
	src: SrcExpr;
	fmt?: FnExpr;
	pre?: FnExpr;
	post?: FnExpr;
}

interface AttrExpr {
	prop: boolean;
	name: string;
	text?: TextExpr[];
	at?: AtExpr;
}

interface NodeExpr {
	tag: string;
	bind: BindExpr;
	attr: AttrExpr[];
	children: (Node | NodeExpr | TextExpr)[];
}

const ExprParser = (() => {
	/**
	 * List of tags bypassed during parsing.
	 */
	let bypass: string[] = [];
	
	/**
	 * Splits text into literals and expressions, delimited by {braces}.
	 */
	function parseText(input: string): string[] {
		// The expressions can contain backtick quoted strings.
		return input.split(/\{\s*((?:`.*`|.)*?)\s*\}/g);
	}
	
	/**
	 * Transpiles expression into tokens, represented as symbols for later pattern matching.
	 */
	function parseExpr<T>(input: string, test: (value: string, tokens: (string | FnExpr)[]) => T): T {
		let mem = <(string | number)[]>[];  // Temporary array to hold the actual values
		let tok = <(string | FnExpr)[]>[];  // Token array after parsing
		let err = false;
		
		// Represents quoted strings and numbers as "A",
		// identifiers (with dot notation) as "I".
		let src = input.replace(/`([^`]*)`|(-?\d+(?:\.\d+)?)|([\w\.]+)/g, (m: string, p1: string, p2: string, p3: string) => {
			if (p1 != undefined) {
				return 'A' + (mem.push(p1) - 1);
			}
			else if (p2 != undefined) {
				return 'A' + (mem.push(parseFloat(p2)) - 1);
			}
			else if (p3 != undefined) {
				return 'I' + (mem.push(p3) - 1);
			}
		});
		
		// Removes spaces around parentheses, comma and arrow.
		src = src.replace(/\s*(?=\(|\)|,|->)|(?<=\(|\)|,|->)\s*/g, '');
		
		// Represents function (with arguments) as "F",
		// "I" symbols as "T".
		src = src.replace(/I(\d+)(?:\(([^)]*)\))?/g, (m: string, p1: number, p2: string) => {
			let word = <string>mem[p1];
			if (p2 != undefined) {
				let args = <(string | number)[]>[];
				let func = <FnExpr>{ name: word, args: args };
				if (p2 = p2.trim()) {
					for (let s of p2.split(',')) {
						// Only quoted strings and numbers are accepted as valid arguments.
						// However, leaving them empty will be treated as NULL.
						if (s) {
							let m = s.match(/^A(\d+)$/);
							if (m) {
								args.push(mem[m[1]]);
							}
							else {
								err = true;
							}
						}
						else {
							args.push(null);
						}
					}
				}
				return 'F' + (tok.push(func) - 1);
			}
			else {
				return 'T' + (tok.push(word) - 1);
			}
		});
		
		// Expects the callback function to return a fully parsed expression on success,
		// or a falsey on error.
		if (!err) {
			let expr = test(src, tok);
			if (expr) {
				return expr;
			}
		}
		
		// The expression is malformed or does not satisfy the testing pattern.
		throw 'Syntax error: ' + input;
	}
	
	/**
	 * Converts kebab-case to camelCase.
	 */
	function kebabToCamel(input: string): string {
		return input.replace(/-./g, (m) => m[1].toUpperCase());
	}
	
	/**
	 * Converts token to FnExpr.
	 */
	function tokenToFn(tok: string | FnExpr, test: string, func: string, text: string, args?: any): FnExpr {
		// This function is intended for quickly obtaining a FnExpr from a token that was generated by the `parseExpr` function.
		// If the provided token is already a FnExpr, simply take it.
		// Otherwise, it's just the name, so create a new FnExpr for it.
		if (test === func) {
			return <FnExpr>tok;
		}
		else if (test === text) {
			return { name: <string>tok, args: (arguments.length === 5) ? args : [] };
		}
	}
	
	/**
	 * Creates data source expression.
	 */
	function srcExpr(k: string, v: string): SrcExpr {
		// If `v` is empty, then the expression was written in the name of the attribute.
		// Applies case conversion for it.
		if (!v) {
			v = kebabToCamel(k.substring(1));
		}
		let a = v.split('.');
		return {
			bind: (k[0] === '$'),
			prop: a[a.length - 1],
			path: a,
		};
	}
	
	/**
	 * Creates template switching expression.
	 */
	function tplExpr(k: string, v: string): TplExpr {
		return {
			name: v,
		};
	}
	
	/**
	 * Creates conditional rendering expression.
	 */
	function ifExpr(k: string, v: string): IfExpr {
		let hnd = parseExpr(v, (test, toks) => tokenToFn(toks[0], test, 'F0', 'T0', undefined));
		
		return {
			not: (k === '!'),
			hnd: hnd,
		};
	}
	
	/**
	 * Creates data modeling expression.
	 */
	function isExpr(k: string, v: string): IsExpr {
		return {
			name: v,
		};
	}
	
	/**
	 * Creates event handling expression.
	 */
	function onExpr(k: string, v: string): OnExpr {
		let hnd = parseExpr(v, (test, toks) => tokenToFn(toks[0], test, 'F0', 'T0'));
		
		return {
			evt: kebabToCamel(k.substring(1)),
			hnd: hnd,
		};
	}
	
	/**
	 * Creates two-way binding expression.
	 */
	function atExpr(k: string, v: string): AtExpr {
		// There must be no literals in the attribute value.
		let a = parseText(v);
		if (a.length !== 3 || a[0] || a[2]) {
			throw 'Syntax error: ' + v;
		}
		
		return parseExpr(a[1], (test, toks) => {
			let m = test.match(/^(?:(F|T)(\d+)->)?(?:\$T(\d+)(?:\:(F|T)(\d+))?)(?:->(F|T)(\d+))?$/);
			if (m) {
				return <AtExpr>{
					evt: kebabToCamel(k.substring(1)),
					src: srcExpr('$', toks[m[3]]),
					fmt: m[4] ? tokenToFn(toks[m[5]], m[4], 'F', 'T') : undefined,
					pre: m[1] ? tokenToFn(toks[m[2]], m[1], 'F', 'T') : undefined,
					post: m[6] ? tokenToFn(toks[m[7]], m[6], 'F', 'T') : undefined,
				};
			}
		});
	}
	
	/**
	 * Creates text expression.
	 */
	function textExpr(v: string): TextExpr[] {
		let a: TextExpr[] = [];
		
		parseText(v).forEach((s, i) => {
			if (i % 2) {
				if (s === '?') {
					a.push({
						src: srcExpr(':', '?'),
						fmt: undefined,
					});
				}
				else {
					a.push(parseExpr(s, (test, toks) => {
						let m = test.match(/^(\$)?T0(:F1|:T1)?$/);
						if (m) {
							return <TextExpr>{
								src: srcExpr(m[1] || ':', <string>toks[0]),
								fmt: tokenToFn(toks[1], m[2], ':F1', ':T1'),
							};
						}
					}));
				}
			}
			else if (s) {
				a.push({
					run: s
				});
			}
		});
		
		return a;
	}
	
	/**
	 * Creates attribute expression.
	 */
	function attrExpr(k: string, v: string): AttrExpr {
		let prop = (k[0] === '.');
		let i = k.indexOf('@');
		if (i > -1) {
			return {
				prop: prop,
				name: k.substring(prop ? 1 : 0, i),
				at: atExpr(k.substring(i), v),
			};
		}
		else {
			return {
				prop: prop,
				name: prop ? k.substring(1) : k,
				text: textExpr(v),
			};
		}
	}
	
	/**
	 * Parses out decorated HTML element into declarative expressions.
	 */
	function parseElement(node: Element): Node | NodeExpr {
		// Element with tag name in `bypass` list will be leave as is.
		if (bypass.includes(node.tagName)) {
			return node;
		}
		
		let bind: BindExpr = {};
		let attr: AttrExpr[] = [];
		let children: (Node | TextExpr | NodeExpr)[] = [];
		
		for (let item of Array.from(node.attributes)) {
			let c = item.name[0];
			let k = item.name;
			let v = item.value;
			
			if (c === ':' || c === '$') {
				bind.src = srcExpr(k, v);
			}
			else if (k === '#') {
				bind.tpl = tplExpr(k, v);
			}
			else if (k === '?' || k === '!') {
				bind.if = ifExpr(k, v);
			}
			else if (k === '%') {
				bind.is = isExpr(k, v);
			}
			else if (c === '@') {
				if (!bind.on) {
					bind.on = [];
				}
				bind.on.push(onExpr(k, v));
			}
			else {
				attr.push(attrExpr(item.name, v));
			}
		}
		
		for (let item of node.childNodes) {
			if (item instanceof Element) {
				children.push(parseElement(item));
			}
			else if (item instanceof Text) {
				children.push(...textExpr(item.nodeValue));
			}
		}
		
		return {
			tag: node.tagName,
			bind: bind,
			attr: attr,
			children: children,
		};
	}
	
	
	return {
		set bypass(value: string[]) {
			bypass = value;
		},
		
		parseElement: parseElement,
		
		parseText: textExpr,
	};
})();
